# 클로저 캡쳐 리스트 (Closure Captrue List)

기본적으로 클로저 표현식은 해당 값에 강한 참조를 사용하여 속성을 캡처합니다.
캡처리스트를 사용하여 클로저에서 값이 캡처되는 방식을 명시적으로 제어할 수 있습니다.

**캡처 리스트의 항목은 클로저가 생성 될 때 초기화** 됩니다. 캡처리스트의 각 항목에 대해 상수는 이름이 같은 상수 또는 변수의 값으로 초기화 됩니다. 예를 들어 아래 코드 a는 캡처리스트에 포함 되어 있지만 b는 포함 되지않아서 다른 결과를 제공합니다.

```
var a = 0
var b = 0
let closure = { [a] in
      print(a, b)
}

a = 10
b = 10
// prints "0 10"
```

b는 클로저 스코프 외부의 값을 가져온 것이므로 값을 공유하기때문에 클로저 외부에서 b를 바꾸게 되면 클로저 내부의 b도 값을 공유하여 바뀌게 됩니다. 그렇지만 a는 클로저가 생성될 때 캡쳐한 값이므로 외부 값과 공유 되지 않아 후에 클로저 외부의 a를 변경하여도 값이 변경 되지 않습니다.

클로저는 강한 참조를 하기 때문에 순환 참조 상태가 발생할 수 있습니다. 순환 참조 상태가 되지 않도록
캡처리스트를 이용하여 참조 대상에 앞에 weak 또는 unowned 키워드를 붙여서 참조 카운트를 증가시키지않으면 됩니다.

```
ex)

let closure = { [weak self] in

}
```

## 정리
- 클로져는 해당 값을 강한 참조하여 캡처한다.
- 강한 참조를 하기때문에 순환 참조가 발생할 수 있다.
- 참조를 하기때문에 값을 공유한다.
- 값을 공유하지 않으려면 캡처리스트를 사용해야한다.
 - 캡처리스트의 속성은 클로저가 생성 될 때 초기화 된다. (캡처 리스트 속성의 값은 클로저 생성 시 캡처하는 값으로 유지 된다.)
- 캡처리스트 속성 생성시에 weak, unowend를 붙여주면 해당 속성은 참조 카운트를 증가시키지 않으므로 순환 참조 상태를 방지할 수 있다.

## 참고 사이트

[캡처리스트 애플 공식 문서](https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID544)